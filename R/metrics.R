#' Neighbourhood
#' 
#' Number of neighbors adjacent to each actor. Calculated excluding self from set of neighbors.
#'
#' @param DT a data.table with column "group" generated by spatsoc::group_pts
#' @param splitBy the column which defines the layers of the network
#' @param id 
#'
#' @return
#' The input DT with additional column "neigh" and optionally "splitNeigh" if a column was provided for the `splitBy` argument. 
#' @export
#' 
#' @import data.table
#'
#' @examples
#' # Load data.table and spatsoc
#' library(data.table)
#' library(spatsoc)
#' 
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#' 
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#' 
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#' 
#' # Spatial grouping with timegroup
#' group_pts(DT, threshold = 5, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup')
#' 
#' layer_neighbors(DT, 'id', splitBy = 'season')
layer_neighbors <- function(DT, id, splitBy = NULL) {
  cols <- c(id, 'group', splitBy)
  
  if (any(!(cols %in% colnames(DT)))) {
    stop(paste0(
      as.character(paste(setdiff(
        cols, colnames(DT)
      ), collapse = ", ")),
      " field(s) provided are not present in input DT"
    ))
  }
  
  # flex splitBy
  if (is.null(splitBy)) {
    DT[, neigh := {
        g <- group
        DT[group %in% g, data.table::uniqueN(get(id)) - 1]
      },
      by = id][]
  } else {
    DT[, neigh := {
      g <- group
      DT[group %in% g, data.table::uniqueN(get(id)) - 1]
    },
    by = id]
    
    
    DT[, splitNeigh := {
      g <- group
      DT[group %in% g, data.table::uniqueN(get(id)) - 1]
    },
    by = c(splitBy, id)][]
  }
}



#' Connective Redundancy
#'
#' When connective redundancy is 0, all edges on all layers 
#' are necessary to preserve the social ties
#' 
#' DT must be result of `layer_neighbors()` and `multidegree` function, having columns "neigh" 
#' and "multideg"
#' 
#' @param DT 
#' @return
#' @export
#'
#' @examples
connective_redudancy <- function(DT) {
  # TODO: Check cols
  # TODO: warn overwrite 
  
  DT[, connredund := 1 - (neigh / multideg)][]
}



#' Multidegree
#'
#' @param DT 
#' @param degree 
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' Column added named multideg
#' @export
#'
#' @examples
multi_degree <- function(DT, degree, id, splitBy = NULL) {
  # TODO: check columns
  # TODO: warn overwrite
  
  DT[, multideg := sum(.SD),
     .SDcol = degree,
     by = c(id, splitBy)][]
}


#' Degree Deviation
#'
#' @param DT 
#' @param degree 
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' Column added named degdev
#' @export
#'
#' @examples
deviation_degree <- function(DT, degree, id, splitBy = NULL) {
  # TODO: check columns
  # TODO: warn overwrite
  
  DT[, degdev := sd(.SD[[1]]),
     .SDcol = degree,
     by = c(id, splitBy)][]
}


#' Relevance
#' 
#' Proportion of neighbours present on each layer.  
#' 
#' 
#' @references Berlingerio, Michele, et al. "Foundations of multidimensional network analysis." 2011 international conference on advances in social networks analysis and mining. IEEE, 2011.
#'
#' @param DT 
#' @param id 
#' @param var 
#' @param splitBy 
#'
#' @return
#' @export
#'
#' @examples
layer_relevance <- function(DT, id, splitBy) {
  # TODO: check for splitNeigh variable and neigh
  # TODO: check overwrite
  
  DT[, relev := splitNeigh / neigh, 
     by = c(id, splitBy)][]
}



#' Calculate graph strength for each graph in a list
#'
#' @param graphLs 
#'
#' @return
#' @export
#'
#' @examples
layer_strength <- function(graphLs) {
  data.table::setnames(data.table::rbindlist(
      lapply(graphLs, function(g) stack(igraph::strength(g))),
    idcol = 'layer')[, ind := as.character(ind)],
    'values', 'graphstrength')
}



#' Layer similarity
#'
#' @param matrices property matrices generated using `property_matrix`
#' @param splitBy column indicating which groups to compare ensuring each group of rows = 2. 
#' @param pattern 
#'
#' @return
#' @export
#'
#' @examples
layer_similarity <- function(matrices, pattern, splitBy) {
  matrices[, layersim := {
    stopifnot(nrow(.SD) == 2)
    cors <- cor(t(.SD[1]), t(.SD[2]), use = 'complete.obs')
  }, by = splitBy, .SDcols = patterns(pattern)]
}



#' Layer similarity - ordinal
#'
#' @inheritParams layer_similarity
#' 
#' Note: splitBy provided to layer_similariy_ordinal must be provided
#' such that sort(unique()) returns the correct, ordinal levels
#' (eg. as an integer)
#'
#' @return
#' @export
#'
#' @examples
layer_similarity_ordinal <- function(matrices, pattern, splitBy) {
  ords <- sort(unique(matrices[[splitBy]]))
  
  lapply(ords, function(low) {
    high <- low + 1
    matrices[data.table::between(get(splitBy), low, high), 
             layersim := {
               fifelse(nrow(.SD) == 2,
                       cor(t(.SD[1]), t(.SD[2]), use = 'na.or.complete'),
                       NA_real_)
             },
             .SDcols = patterns(pattern)]
  })
  
  matrices
}


#' Property Matrix
#' 
#' @param DT 
#' @param id 
#' @param layer 
#' @param metric 
#' @param by
#'
#' @return
#' @references BrÃ³dka P, Chmiel A,Magnani M, Ragozini G. 2018 Quantifying layer
#' similarity in multiplex networks: a systematic study. R.Soc.opensci. 5:171747.
#' http://dx.doi.org/10.1098/rsos.171747
#' 
#' @export
#'
#' @examples
property_matrix <- function(DT, id, metric, by, layer = 'layer') {
  zzz <- DT[, list(list(data.table::dcast(
    .SD,
    reformulate(..id, response = ..layer),
    value.var = ..metric
  ))),
  by = by][, data.table::rbindlist(V1, idcol = 'i', fill = TRUE)]
  data.table::setnames(zzz, 'i', by)
  zzz
}






#' Edge overlap
#'
#' @param graphLs 
#'
#' @return
#' @export
#'
#' @examples
edge_overlap <- function(edges) {
  # count number of unique edges
  # for each unique edge, count number of layers it exists on / total
  # average all overlap 
  
  uniqueEdges <- edges[, uniqueN(dyadID)]
  uniqueLayers <- edges[, uniqueN(layer)]
  
  edges[, edgeoverlap := .N / uniqueLayers, by = dyadID]
  
  edgeoverlapml <- unique(edges[, .(layer, dyadID, edgeoverlap)])[, mean(edgeoverlap)]
  propedges <- edges[, uniqueN(dyadID) / uniqueEdges, by = layer]
  
  propedges[, .(layer, propedges = V1, edgeoverlap = edgeoverlapml)]
}


#' Edge overlap matrix
#' 
#' Layer A vs Layer B, count overlap
#'
#' @param edges 
#'
#' @return
#' @export
#'
#' @examples
edge_overlap_mat <- function(edges) {
  crossprod(table(edges[, .(dyadID = unique(dyadID)), layer][, .(dyadID, layer)]))
}
