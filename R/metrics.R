#' Neighbourhood
#' 
#' Number of neighbors adjacent to each actor. Calculated excluding self from set of neighbors.
#'
#' @param DT a data.table with column "group" generated by spatsoc::group_pts
#' @param splitBy the column which defines the layers of the network
#' @param id 
#'
#' @return
#' The input DT with additional column "neigh" and optionally "splitNeigh" if a column was provided for the `splitBy` argument. 
#' @export
#' 
#' @import data.table
#'
#' @examples
#' # Load data.table and spatsoc
#' library(data.table)
#' library(spatsoc)
#' 
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#' 
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#' 
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#' 
#' # Spatial grouping with timegroup
#' group_pts(DT, threshold = 5, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup')
#' 
#' layer_neighbors(DT, 'id', splitBy = 'season')
layer_neighbors <- function(DT, id, splitBy = NULL) {
  cols <- c(id, 'group', splitBy)
  
  if (any(!(cols %in% colnames(DT)))) {
    stop(paste0(
      as.character(paste(setdiff(
        cols, colnames(DT)
      ), collapse = ", ")),
      " field(s) provided are not present in input DT"
    ))
  }
  
  # flex splitBy
  if (is.null(splitBy)) {
    DT[, neigh := {
        g <- group
        DT[group %in% g, data.table::uniqueN(get(id)) - 1]
      },
      by = id][]
  } else {
    DT[, neigh := {
      g <- group
      DT[group %in% g, data.table::uniqueN(get(id)) - 1]
    },
    by = id]
    
    
    DT[, splitNeigh := {
      g <- group
      DT[group %in% g, data.table::uniqueN(get(id)) - 1]
    },
    by = c(splitBy, id)][]
  }
}



#' Connective Redundancy
#'
#' When connective redundancy is 0, all edges on all layers 
#' are necessary to preserve the social ties
#' 
#' DT must be result of `neigh()` function, having columns "splitNeigh" 
#' and "neigh"
#' 
#' @param DT 
#' @return
#' @export
#'
#' @examples
connective_redudancy <- function(DT) {
  # TODO: Check cols
  # TODO: warn overwrite 
  
  DT[, connredund := 1 - (splitNeigh / neigh)][]
}



#' Multidegree
#'
#' @param DT 
#' @param degree 
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' Column added named multideg
#' @export
#'
#' @examples
multi_degree <- function(DT, degree, id, splitBy = NULL) {
  # TODO: check columns
  # TODO: warn overwrite
  
  DT[, multideg := sum(.SD),
     .SDcol = degree,
     by = c(id, splitBy)][]
}


#' Degree Deviation
#'
#' @param DT 
#' @param degree 
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' Column added named degdev
#' @export
#'
#' @examples
deviation_degree <- function(DT, degree, id, splitBy = NULL) {
  # TODO: check columns
  # TODO: warn overwrite
  
  DT[, degdev := sd(.SD[[1]]),
     .SDcol = degree,
     by = c(id, splitBy)][]
}


#' Relevance
#' 
#' Proportion of neighbours present on each layer.  
#' 
#' 
#' @references Berlingerio, Michele, et al. "Foundations of multidimensional network analysis." 2011 international conference on advances in social networks analysis and mining. IEEE, 2011.
#'
#' @param DT 
#' @param id 
#' @param var 
#' @param splitBy 
#'
#' @return
#' @export
#'
#' @examples
layer_relevance <- function(DT, id, splitBy) {
  # TODO: check for splitNeigh variable and neigh
  # TODO: check overwrite
  
  DT[, relev := splitNeigh / neigh, 
     by = c(id, splitBy)][]
}



#' Calculate graph strength for each graph in a list
#'
#' @param graphLs 
#'
#' @return
#' @export
#'
#' @examples
layer_strength <- function(graphLs) {
  data.table::setnames(data.table::rbindlist(
      lapply(graphLs, function(g) stack(igraph::strength(g))),
    idcol = 'layer')[, ind := as.character(ind)],
    'values', 'graphstrength')
}



#' Layer correlation
#' @param gLs Expects a list of two weighted graphs 
#' @param attr Graph attribute to use, default assuming the weight is stored. 
#'
#' @return
#' @export
#'
#' @examples
layer_correlation <- function(gLs, attr = 'weight') {
  if (length(gLs) != 2) {
    stop('gLs must be length 2')
  }
  cor(c(igraph::as_adj(
    gLs[[1]], attr = attr, sparse = FALSE
  )), c(igraph::as_adj(
    gLs[[2]], attr = attr, sparse = FALSE
  )))
}



#' Property Matrix
#' 
#' @param DT 
#' @param id 
#' @param layer 
#' @param metric 
#'
#' @return
#' @references BrÃ³dka P, Chmiel A,Magnani M, Ragozini G. 2018 Quantifying layer
#' similarity in multiplex networks: a systematic study. R.Soc.opensci. 5:171747.
#' http://dx.doi.org/10.1098/rsos.171747
#' 
#' @export
#'
#' @examples
property_matrix <- function(DT, id, layer, metric) {
  data.table::dcast(DT, reformulate(id, response = layer), value.var = metric)
}


