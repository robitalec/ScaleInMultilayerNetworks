#' Neighbourhood
#' 
#' Number of neighbors adjacent to each actor. Calculated excluding self from set of neighbors.
#'
#' @param DT a data.table with column "group" generated by spatsoc::group_pts
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' The input DT with additional column "neighborhood" and optionally "splitNeighorhood" if a column was provided for the `splitBy` argument. 
#' @export
#' 
#' @import data.table
#'
#' @examples
#' # Load data.table and spatsoc
#' library(data.table)
#' library(spatsoc)
#' 
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#' 
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#' 
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#' 
#' # Spatial grouping with timegroup
#' group_pts(DT, threshold = 5, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup')
#' 
#' neigh(DT, 'id', splitBy = 'season')
layer_neighbors <- function(DT, id, splitBy = NULL) {
  if (any(!(c(id, 'group', splitBy) %in% colnames(DT)))) {
    stop(paste0(
      as.character(paste(setdiff(
        c(id, 'group', splitBy), colnames(DT)
      ), collapse = ", ")),
      " field(s) provided are not present in input DT"
    ))
  }
  
  # flex splitBy
  if (is.null(splitBy)) {
    DT[, neighborhood := {
        g <- group
        DT[group %in% g, data.table::uniqueN(get(id)) - 1]
      },
      by = id][]
  } else {
    DT[, neighborhood := {
      g <- group
      DT[group %in% g, data.table::uniqueN(get(id)) - 1]
    },
    by = id]
    
    
    DT[, splitNeighborhood := {
      g <- group
      DT[group %in% g, data.table::uniqueN(get(id)) - 1]
    },
    by = c(splitBy, id)][]
  }
}



#' Connective Redundancy
#'
#' When connective redundancy is 0, all edges on all layers 
#' are necessary to preserve the social ties
#' 
#' DT must be result of `neigh()` function, having columns "splitNeighborhood" 
#' and "neighborhood"
#' 
#' @param DT 
#' @return
#' @export
#'
#' @examples
connective_redudancy <- function(DT) {
  # TODO: Check cols
  # TODO: warn overwrite 
  
  DT[, connredund := 1 - (splitNeighborhood / neighborhood)][]
}



#' Multidegree
#'
#' @param DT 
#' @param degree 
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' Column added named multideg
#' @export
#'
#' @examples
multi_degree <- function(DT, degree, id, splitBy = NULL) {
  # TODO: check columns
  # TODO: warn overwrite
  
  DT[, multideg := sum(.SD),
     .SDcol = degree,
     by = c(id, splitBy)][]
}


#' Degree Deviation
#'
#' @param DT 
#' @param degree 
#' @param splitBy this is not the splitBy (eg season)
#' @param id 
#'
#' @return
#' Column added named degdev
#' @export
#'
#' @examples
deviation_degree <- function(DT, degree, id, splitBy = NULL) {
  # TODO: check columns
  # TODO: warn overwrite
  
  DT[, degdev := sd(.SD[[1]]),
     .SDcol = degree,
     by = c(id, splitBy)][]
}


#' Relevance
#' 
#' Proportion of neighbours present on each layer.  
#' 
#' 
#' @references Berlingerio, Michele, et al. "Foundations of multidimensional network analysis." 2011 international conference on advances in social networks analysis and mining. IEEE, 2011.
#'
#' @param DT 
#' @param id 
#' @param var 
#' @param splitBy 
#'
#' @return
#' @export
#'
#' @examples
layer_relevance <- function(DT, id, var, splitBy) {
  # TODO: check for splitNeighborhood variable and multidegree
  # TODO: check overwrite
  
  DT[, relev := splitNeighborhood / multideg, 
     by = c(id, splitBy)][]
}



#' Calculate eigenvector centrality for each graph in a list
#'
#' @param graphLs 
#' @param idcol 
#'
#' @return
#' @export
#'
#' @examples
layer_eigen <- function(graphLs, idcol) {
  data.table::rbindlist(
    lapply(
      lapply(graphLs, function(g) {
        igraph::eigen_centrality(g)$vector}), stack),
    idcol = 'layer')
}



#' Layer correlation
#'
#' @param gLs 
#' @param attr 
#'
#' @return
#' @export
#'
#' @examples
layer_correlation <- function(gLs, attr = 'weight') {
  if (length(gLs) != 2) {
    stop('gLs must be length 2')
  }
  cor(c(igraph::as_adj(
    gLs[[1]], attr = attr, sparse = FALSE
  )), c(igraph::as_adj(
    gLs[[2]], attr = attr, sparse = FALSE
  )))
}